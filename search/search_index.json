{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pypox-200","title":"Pypox 2.0.0","text":"<p>Pypox 2.0 is a lightweight and fast Python web framework built on top of Starlette. It aims to provide a flexible and modular development experience for web applications.</p> <p>Key Features:</p> <ul> <li>File-based routing: Pypox leverages a file-based approach for defining application routes, making it intuitive and easy to manage.</li> <li>Modular design: The framework adopts a modular architecture, allowing developers to break down their applications into smaller, reusable components.</li> <li>Processor-based functions: Pypox introduces processor functions that handle request validation and transformation, simplifying the process of preparing data for your application logic.</li> </ul> <p>Advantages:</p> <ul> <li>Ease of use: Pypox's file-based routing and modular design contribute to a user-friendly development experience, especially for beginners.</li> <li>Performance: Built upon Starlette, Pypox is known for its speed and efficiency, making it suitable for web applications requiring fast performance.</li> <li>Flexibility: The modular structure allows developers to customize their development process and integrate Pypox with other libraries and frameworks.</li> </ul> <p>Installation Guide:</p> <ol> <li>Prerequisites: Ensure you have Python 3.7 or above installed on your system. You can verify the installation by running <code>python --version</code> in your terminal.</li> <li>Install Pypox: Use the pip package manager to install Pypox:</li> </ol> <pre><code>pip install pypox\n</code></pre> <p>Usage Example:</p> <p>A basic Pypox application demonstrating a processing function:</p> <pre><code>from pypox.processing.base import processor\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom pypox._types import QueryStr,QueryInt,BodyDict\n\napp = Starlette()\n\n@processor()\nasync def homepage(name:QueryStr,age:QueryInt,info:BodyDict) -&gt; JSONResponse:\n    return JSONResponse({\"message\": f\"Hello, {name}! You are {age} years old. Info: {info}\"})\n\napp.add_route(\"/\", homepage, methods=[\"GET\"])\n</code></pre> <p>Dependencies:</p> <ul> <li>Python (&gt;= 3.7)</li> <li>Starlette</li> </ul> <p>Limitations:</p> <ul> <li>Early stage: As Pypox is still under development, it might have limited features or functionalities compared to more mature frameworks.</li> <li>Documentation: Comprehensive documentation might not be readily available yet, requiring developers to rely on source code and community resources for guidance.</li> </ul> <p>Further Resources:</p> <ul> <li>PyPI page: [pypi pypox ON PyPI pypi.org]</li> </ul> <p>This documentation overview provides a more comprehensive introduction to Pypox 2.0+. Remember that the framework is still under development, so keep an eye out for updates and refer to the official resources for the latest information.</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#contributions","title":"Contributions","text":"<p>Contributions to enhance Pypox by supporting additional functionality, improving error handling, or expanding conventions are welcome! Feel free to create pull requests or raise issues.</p>"},{"location":"about/#mit-license-for-business-use","title":"MIT License (for Business Use)","text":"<p>Copyright (c) [2023] [Po-key]</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/#contact","title":"Contact","text":"<p>For any inquiries or support, reach out to the maintainers through pokey.business2023@gmail.com.</p>"},{"location":"conventions/","title":"Conventions","text":""},{"location":"conventions/#conventions","title":"Conventions","text":"<ul> <li>Pypox expects modules in the specified directory to adhere to certain file naming conventions:</li> <li><code>socket.py</code></li> <li><code>config.py</code></li> <li><code>startup.py</code></li> <li><code>shutdown.py</code></li> <li><code>get.py</code></li> <li><code>post.py</code></li> <li><code>put.py</code></li> <li><code>delete.py</code></li> </ul>"},{"location":"conventions/#file-naming-conventions","title":"File Naming Conventions:","text":"<ol> <li> <p>Socket Handling: Module for Web Socket handling.</p> </li> <li> <p>Example: <code>socket.py</code></p> </li> <li> <p>Configuration: Module containing router / main application configurations.</p> </li> <li> <p>Example: <code>config.py</code></p> </li> <li> <p>Startup Routine: Module for defining startup procedures.</p> </li> <li> <p>Example: <code>startup.py</code></p> </li> <li> <p>Shutdown Routine: Module for defining shutdown procedures.</p> </li> <li> <p>Example: <code>shutdown.py</code></p> </li> <li> <p>HTTP Methods (CRUD Operations):</p> </li> <li>Module for handling HTTP GET requests.<ul> <li>Example: <code>get.py</code></li> </ul> </li> <li>Module for handling HTTP POST requests.<ul> <li>Example: <code>post.py</code></li> </ul> </li> <li>Module for handling HTTP PUT requests.<ul> <li>Example: <code>put.py</code></li> </ul> </li> <li>Module for handling HTTP DELETE requests.<ul> <li>Example: <code>delete.py</code></li> </ul> </li> </ol>"},{"location":"conventions/#endpoint-naming-conventions","title":"Endpoint Naming Conventions:","text":"<p>For the HTTP methods mentioned above, the expected naming conventions for defining endpoints follow the HTTP verbs in uppercase:</p> <ul> <li> <p><code>GET</code> endpoint:</p> </li> <li> <p>The module should define an <code>endpoint</code> function, often named as <code>endpoint</code> or <code>get</code>, responsible for handling GET requests.</p> </li> <li> <p><code>POST</code> endpoint:</p> </li> <li> <p>The module should define an <code>endpoint</code> function, often named as <code>endpoint</code> or <code>post</code>, responsible for handling POST requests.</p> </li> <li> <p>Similarly for <code>PUT</code>, <code>DELETE</code>, and other HTTP methods.</p> </li> </ul>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#example","title":"Example:","text":"<p>Let's consider an example directory structure adhering to these conventions:</p> <pre><code>/project_directory\n    |-- socket.py\n    |-- config.py\n    |-- startup.py\n    |-- shutdown.py\n    |-- get.py\n    |-- post.py\n    |-- put.py\n    |-- delete.py\n    |-- other_module.py\n    |-- ...\n</code></pre> <p>In this scenario:</p> <ul> <li><code>socket.py</code> handles socket-related operations.</li> <li><code>config.py</code> stores application configurations.</li> <li><code>startup.py</code> contains procedures executed on application startup.</li> <li><code>shutdown.py</code> contains procedures executed on application shutdown.</li> <li><code>get.py</code>, <code>post.py</code>, <code>put.py</code>, <code>delete.py</code>, and potentially other similar files each define endpoints for handling GET, POST, PUT, DELETE requests, respectively.</li> </ul> <p>Pypox will recognize and utilize these modules for building the FastAPI application and API routers based on their functionalities and the defined conventions.</p>"},{"location":"examples/#complex-example","title":"Complex Example","text":"<p>Creating a more complex example using Pypox involves setting up a directory structure and implementing modules adhering to the specified naming conventions. Here's a hypothetical example demonstrating how Pypox can dynamically generate a FastAPI application with different modules handling various functionalities:</p> <p>Let's create a directory structure following the conventions:</p> <pre><code>/my_api_project\n    |-- socket.py\n    |-- config.py\n    |-- startup.py\n    |-- shutdown.py\n    |-- main.py\n    |-- users\n    |    |-- get.py\n    |    |-- post.py\n    |    |-- put.py\n    |    |-- delete.py\n    |-- products\n         |-- get.py\n         |-- post.py\n         |-- put.py\n         |-- delete.py\n</code></pre>"},{"location":"examples/#implementation-of-modules","title":"Implementation of Modules","text":""},{"location":"examples/#socketpy","title":"<code>socket.py</code>","text":"<pre><code># socket.py\nfrom fastapi import WebSocket\n\nasync def socket(websocket: WebSocket):\n    # Handle WebSocket connection logic\n    pass\n</code></pre>"},{"location":"examples/#startuppy","title":"<code>startup.py</code>","text":"<pre><code># startup.py\n\ndef __call__():\n    # Execute startup procedures\n    pass\n</code></pre>"},{"location":"examples/#shutdownpy","title":"<code>shutdown.py</code>","text":"<pre><code># shutdown.py\n\ndef __call__():\n    # Execute shutdown procedures\n    pass\n</code></pre> <p>Pypox identifies <code>startup.py</code> and <code>shutdown.py</code> modules and attempts to invoke them as callable functions. For this purpose, it uses the <code>__call__</code> method within these modules to initiate the program at startup and gracefully shut down the program when required.</p>"},{"location":"examples/#mainpy","title":"<code>main.py</code>","text":"<pre><code># main.py\nfrom fastapi import FastAPI\nfrom pypox import Pypox\nimport os\napp = Pypox(os.path.dirname(__file__))() # this will return a configured FastAPI Instance\n\n# Any additional configurations for the FastAPI application\n# For example: CORS settings, middleware, etc.\n</code></pre>"},{"location":"examples/#usersgetpy","title":"<code>users/get.py</code>","text":"<pre><code># users/get.py\nasync def endpoint():\n    # Logic to retrieve users\n    pass\n</code></pre> <p>Similarly, implement <code>post.py</code>, <code>put.py</code>, and <code>delete.py</code> under the <code>users</code> directory with corresponding HTTP methods.</p>"},{"location":"examples/#productsgetpy-postpy-putpy-deletepy","title":"<code>products/get.py</code>, <code>post.py</code>, <code>put.py</code>, <code>delete.py</code>","text":"<p>Implement similar functions as in the <code>users</code> directory but for handling product-related endpoints.</p>"},{"location":"examples/#usage-example","title":"Usage Example","text":"<pre><code># main.py\nfrom pypox import Pypox\nimport uvicorn\nimport os\n\npypox_instance = Pypox(os.path.dirname(__file__))\nfastapi_app = pypox_instance()\n\nif __name__ == \"__main__\":\n    uvicorn.run(fastapi_app, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>When run, Pypox will dynamically generate a FastAPI application based on the provided directory structure and module contents. It will recognize the configured WebSocket handling, endpoints for users and products, startup and shutdown procedures, and any additional configurations specified.</p> <p>This demonstrates how Pypox can automate the setup of a FastAPI application by following naming conventions and organizing functionalities within modules.</p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>Po-key is committed to continuous evolution and enhancement to elevate the web development experience. Our roadmap includes the following key objectives:</p>"},{"location":"roadmap/#1-feature-expansion","title":"1. Feature Expansion","text":"<ul> <li>API Construction: Strengthening capabilities for developing APIs efficiently.</li> <li>Web Integration: Streamlining the process of integrating APIs into web applications for seamless functionality.</li> </ul>"},{"location":"roadmap/#2-framework-development","title":"2. Framework Development","text":"<ul> <li>Custom API Framework: Crafting a versatile API framework, departing from dependency on FastAPI. This framework will offer flexibility in adhering to conventions and compatibility with FastAPI-like structures.</li> <li>ASGI Specification Compliance: Aligning with the ASGI (Asynchronous Server Gateway Interface) specification to ensure compatibility and seamless integration across the Python ecosystem.</li> <li>SQL Integration: Integrating SQL databases using SQLAlchemy that inherently supports asynchronous operations.</li> </ul>"},{"location":"roadmap/#3-enhanced-flexibility","title":"3. Enhanced Flexibility","text":"<ul> <li>Conventional Use: Providing a flexible system empowering users to craft personalized conventions.</li> <li>Problem Mitigation: Addressing and rectifying existing issues within FastAPI, especially concerning API documentation for a smoother experience.</li> </ul>"},{"location":"roadmap/#4-protocol-integration","title":"4. Protocol Integration","text":"<ul> <li>WebSocket and HTTP Integration: Seamlessly integrating WebSocket and HTTP protocols.</li> <li>Specification Standardization: Developing a proprietary specification compliant with open API standards to standardize and optimize protocol usage.</li> </ul>"},{"location":"roadmap/#5-database-expansions","title":"5. Database Expansions.","text":"<ul> <li>NoSQL Integration: Future plans to incorporate NoSQL databases, expanding the range of supported database types for enhanced flexibility and adaptability.</li> </ul> <p>Pypox is dedicated to these objectives, ensuring a more robust, flexible, and integrated web development experience while maintaining compliance with open API standards and protocols.</p>"},{"location":"examples/apps/security/","title":"Security","text":""},{"location":"examples/apps/security/#building-oauth2-security-middleware-with-pypox","title":"Building OAuth2 Security Middleware with Pypox","text":"<p>This tutorial aims to guide you through creating a security middleware using the OAuth2 authentication code flow within the Pypox framework.</p>"},{"location":"examples/apps/security/#project-setup-with-poetry-virtual-environment","title":"Project Setup with Poetry Virtual Environment","text":"<p>To begin, let's set up the project within a Poetry virtual environment for better package management and isolation.</p> <ol> <li> <p>Start by creating a folder named <code>tutorials</code>. This folder will house our Pypox project.</p> </li> <li> <p>Inside the <code>tutorials</code> folder, structure the following components:</p> </li> <li> <p>An <code>__init__.py</code> file.</p> </li> <li> <p>Subfolders:</p> <ul> <li><code>tests</code></li> <li><code>basic_security</code>, which includes:</li> <li><code>main.py</code></li> <li><code>startup.py</code></li> <li><code>shutdown.py</code></li> <li><code>middleware.py</code></li> <li>Subfolders:<ul> <li><code>database</code></li> <li><code>routes</code></li> <li><code>templates</code> (for Jinja2 templates).</li> </ul> </li> </ul> </li> <li> <p>In the <code>main.py</code> file within the <code>basic_security</code> folder, add the provided code snippet:</p> </li> </ol> <pre><code>from fastapi import FastAPI\nfrom pypox import Pypox\nimport os\nfrom tutorials.basic_security.middleware import OAuth2Middleware\n\napp: FastAPI = Pypox(os.path.dirname(__file__))()\n\napp.add_middleware(\n    OAuth2Middleware,\n    authorize_url=\"/authorize/\",\n    token_url=\"/token/\",\n    encryption_key=\"encryption_key\",\n    decryption_key=\"decryption_key\",\n    template_dir=os.path.dirname(__file__) + \"/templates\",\n)\n</code></pre> <p>This setup initializes our Pypox project and introduces the initial structure required for implementing OAuth2 security middleware using Pypox.</p>"},{"location":"examples/apps/security/#developing-custom-oauth2middleware","title":"Developing Custom OAuth2Middleware","text":"<p>Now, let's delve into crafting our custom <code>OAuth2Middleware</code> to manage OAuth2 authentication within our Pypox project.</p>"},{"location":"examples/apps/security/#importing-necessary-modules","title":"Importing Necessary Modules","text":"<p>Begin by importing essential modules and libraries required for our middleware:</p> <pre><code>from uuid import uuid4\nfrom fastapi import Request, Response\nfrom fastapi.responses import JSONResponse, RedirectResponse\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.authentication import AuthenticationError\nfrom fastapi.templating import Jinja2Templates\nfrom base64 import b64decode\nfrom jose import jwt, JWTError\nfrom urllib import parse\nimport datetime\n\nclass OAuth2Middleware(BaseHTTPMiddleware):\n    def __init__(\n        self,\n        app,\n        authorize_url: str,\n        token_url: str,\n        encryption_key: str,\n        decryption_key: str,\n        unprotected_routes: list = [],\n        template_dir: str | None = None,\n    ) -&gt; None:\n        super().__init__(app)\n        # Set variables\n        self.authorize_url: str = authorize_url\n        self.token_url: str = token_url\n        self.encryption_key: str = encryption_key\n        self.decryption_key: str = decryption_key\n        self.unprotected_routes: list = unprotected_routes\n        # Create Jinja2Templates instance if template_dir is provided\n        if template_dir:\n            self.templates: Jinja2Templates = Jinja2Templates(directory=template_dir)\n</code></pre> <p>This code initializes our custom middleware class <code>OAuth2Middleware</code> and defines necessary variables essential for OAuth2 authentication handling within Pypox.</p>"},{"location":"examples/apps/security/#developing-request-dispatcher-function","title":"Developing Request Dispatcher Function","text":"<p>To manage the flow of requests and handle OAuth2 authentication processes, we'll create an asynchronous function named <code>dispatch(self, request: Request, call_next)</code>.</p> <pre><code>async def dispatch(self, request: Request, call_next) -&gt; Response:\n    if request.url.path == self.authorize_url:\n        return await self.authorize(request)\n    elif request.url.path == self.token_url:\n        return await self.token(request)\n    elif request.headers.get(\"Authorization\"):\n        return await self.protected(request, call_next)\n    elif request.url.path in self.unprotected_routes:\n        return await call_next(request)\n    else:\n        return Response()\n</code></pre> <p>This <code>dispatch</code> function serves as a central handler for incoming requests, directing them based on their paths:</p> <ul> <li>Authorize Function (<code>/authorize/</code>): Handles HTTP GET method to initiate the OAuth2 flow process.</li> <li>Token Function (<code>/token/</code>): Manages the HTTP POST method to generate and return the access token.</li> <li>Protected Function: Responsible for decrypting the access token and controlling access to protected routes.</li> <li>Unprotected Routes: Allows passage through for routes defined as unprotected.</li> <li>Default Response: Returns an empty response for other unspecified paths.</li> </ul> <p>Each path is directed to its respective function for processing based on the URL provided in the incoming request. This structure forms the foundation for managing OAuth2 authentication within the middleware, guiding requests through the authentication flow and protected route access.</p>"},{"location":"examples/apps/security/#implementing-oauth2-routes","title":"Implementing OAuth2 Routes","text":"<p>Now, let's define three asynchronous functions: <code>authorize</code>, <code>token</code>, and <code>protected</code>, responsible for handling authentication within your system.</p>"},{"location":"examples/apps/security/#step-by-step-guide-to-implementing-the-authorize-endpoint","title":"Step-by-Step Guide to Implementing the Authorize Endpoint","text":""},{"location":"examples/apps/security/#1-define-the-authorize-function","title":"1. Define the <code>authorize</code> Function","text":"<p>The <code>authorize</code> function initializes the OAuth2 flow process by handling the HTTP GET method.</p> <pre><code>async def authorize(self, request: Request):\n    # Retrieve query parameters\n    # Check and render HTML if required\n    # Generate and store authorization code\n    return RedirectResponse(url=f\"{redirect_uri}?code={code}&amp;state={state}\")\n</code></pre>"},{"location":"examples/apps/security/#2-extract-query-parameters","title":"2. Extract Query Parameters","text":"<p>Retrieve essential query parameters from the incoming request:</p> <pre><code># code above\nclient_id = request.query_params.get(\"client_id\")\nredirect_uri = request.query_params.get(\"redirect_uri\")\nresponse_type = request.query_params.get(\"response_type\")\nstate = request.query_params.get(\"state\")\nscope = request.query_params.get(\"scope\")\nshow_dialog = request.query_params.get(\"show_dialog\") or \"true\"\n# code below\n</code></pre>"},{"location":"examples/apps/security/#3-validate-required-parameters","title":"3. Validate Required Parameters","text":"<p>Ensure all mandatory parameters are present:</p> <pre><code>if not all([client_id, redirect_uri, response_type]):\n    return Response(\"Missing required parameters\", status_code=400)\n</code></pre>"},{"location":"examples/apps/security/#4-implement-authorization-logic","title":"4. Implement Authorization Logic","text":"<p>Perform the necessary authorization logic according to your system requirements.</p> <pre><code># Check if show_dialog is true and render HTML if required\nif show_dialog.lower() == \"true\":\n    return self.templates.TemplateResponse(\n        request=request,\n        name=\"authorize.html\",\n        context={\"scope\": scope},\n    )\n\n# Generate a unique authorization code and store it\ncode = str(uuid4())\n\n# store the code for temporary use ( this will be helpful later to verify code )\nself.auth_codes[code] = {\n    \"client_id\": client_id,\n    \"redirect_uri\": redirect_uri,\n    \"response_type\": response_type,\n    \"state\": state,\n    \"scope\": scope,\n}\n\n# Redirect with authorization code and state\nreturn RedirectResponse(url=f\"{redirect_uri}?code={code}&amp;state={state}\")\n</code></pre>"},{"location":"examples/apps/security/#token-endpoint","title":"Token Endpoint","text":"<p>The <code>token</code> function, an HTTP POST endpoint, manages the access token generation process.</p> <pre><code>async def token(self, request: Request):\n    # Validate client credentials\n    # Generate access token and refresh token\n    return JSONResponse(content={...})\n</code></pre>"},{"location":"examples/apps/security/#protected-endpoint","title":"Protected Endpoint","text":"<p>Lastly, the <code>protected</code> function secures FastAPI routes by handling the security measures.</p> <pre><code>async def protected(self, request: Request, call_next):\n    # Verify bearer token and decrypt credentials\n    return await call_next(request)\n</code></pre> <p>These functions cater to distinct stages of the OAuth2 flow: initiation, token generation, and secure access to protected routes within your FastAPI system.</p>"},{"location":"examples/apps/security/#managing-protected-routes","title":"Managing Protected Routes","text":"<p>To exemplify handling protected routes, let's create a sample route at '/routes/protected/' within our FastAPI application.</p> <pre><code>async def endpoint():\n    return {\"message\":\"Hello world!\"}\n</code></pre> <p>Now, let's simulate a request to this protected endpoint using FastAPI's <code>TestClient</code>.</p> <pre><code>from fastapi.testclient import TestClient\nfrom tutorials.basic_security.main import app\n\nclient: TestClient = TestClient(app)\n\nresponse = self.client.get(\n    \"/protected/\",\n    headers={\n        \"Authorization\": f\"Bearer {self.token['user']['access_token']}\",\n    },\n)\nprint(response.json())\n</code></pre> <p>Upon execution, the output will be:</p> <pre><code>{\"message\":\"Hello World!\"}\n</code></pre> <p>You can seamlessly integrate this code snippet into your Pypox/FastAPI application to manage and secure protected routes effectively. This showcases how to make authenticated requests to protected endpoints within your system.</p>"},{"location":"installation/pipenv/","title":"Pypox Installation Guide","text":""},{"location":"installation/pipenv/#requirements","title":"Requirements","text":"<ul> <li>Python (3.6 and above)</li> </ul>"},{"location":"installation/pipenv/#installation-steps","title":"Installation Steps","text":"<p>Pypox is a self-contained Python module and does not require specific installation steps. However, you can set it up using the following:</p> <ol> <li>Create a Virtual Environment (Optional but recommended):</li> </ol> <pre><code>python -m venv pypox_env\nsource pypox_env/bin/activate  # For Linux/Mac\n./pypox_env/Scripts/activate   # For Windows\n</code></pre> <ol> <li>Install Pypox:</li> </ol> <pre><code>pip install pypox\n</code></pre> <ol> <li> <p>Usage:</p> </li> <li> <p>Ensure the modules within the specified directory follow the naming conventions described in the documentation.</p> </li> <li>Use Pypox by instantiating the <code>Pypox</code> class and generating the FastAPI application and API routers.</li> </ol> <p>Example:</p> <pre><code>from pypox import Pypox\nimport uvicorn\n\npypox_instance = Pypox(\"your_directory_path\")\nfastapi_app = pypox_instance()\n\nif __name__ == \"__main__\":\n    uvicorn.run(fastapi_app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"installation/pipenv/#uninstallation","title":"Uninstallation","text":"<p>To remove Pypox, simply run the command <code>pip uninstall pypox</code></p>"},{"location":"installation/pipenv/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Ensure the modules follow the specified naming conventions to be recognized by Pypox.</li> <li>Check for any missing dependencies (<code>fastapi</code> and <code>uvicorn</code>).</li> <li>If encountering issues, refer to the documentation or create an issue in the repository.</li> </ul> <p>For more detailed information, refer to the Pypox README or documentation.</p> <p>If you encounter any problems or need further assistance, contact the maintainers via karlalferezfx@gmail.com.</p>"},{"location":"installation/poetry/","title":"Poetry","text":""},{"location":"installation/poetry/#pypox-poetry-installation-guide","title":"Pypox Poetry Installation Guide","text":""},{"location":"installation/poetry/#requirements","title":"Requirements","text":"<ul> <li>Python (3.6 and above)</li> </ul>"},{"location":"installation/poetry/#installation-steps","title":"Installation Steps","text":"<p>Pypox is a self-contained Python module and can be easily set up using Poetry, following these steps:</p> <ol> <li>Create a Virtual Environment (Optional but recommended):</li> </ol> <pre><code>poetry init\npoetry shell\n</code></pre> <ol> <li>Install Pypox:</li> </ol> <pre><code>poetry add pypox\n</code></pre>"},{"location":"installation/poetry/#usage","title":"Usage","text":"<p>Ensure the modules within the specified directory follow the naming conventions described in the documentation.</p> <p>Use Pypox by instantiating the Pypox class and generating the FastAPI application and API routers. Example:</p> <pre><code>from pypox import Pypox\nimport uvicorn\n\npypox_instance = Pypox(\"your_directory_path\")\nfastapi_app = pypox_instance()\n\nif __name__ == \"__main__\":\n    uvicorn.run(fastapi_app, host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"installation/poetry/#uninstallation","title":"Uninstallation","text":"<p>To remove Pypox, simply run the command:</p> <pre><code>poetry remove pypox\n</code></pre>"},{"location":"installation/poetry/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Ensure the modules follow the specified naming conventions to be recognized by Pypox.</li> <li>Check for any missing dependencies (fastapi and uvicorn).</li> <li>If encountering issues, refer to the documentation or create an issue in the repository.</li> </ul> <p>For more detailed information, refer to the Pypox README or documentation.</p> <p>For additional assistance, contact the maintainers via karlalferezfx@gmail.com.</p>"},{"location":"references/compiler/","title":"Compiler","text":""},{"location":"references/compiler/#__init__","title":"<code>__init__</code>","text":"<pre><code>def __init__(directory: str) -&gt; None:\n</code></pre> <p>Purpose: Initializes an instance of the class.</p> <ul> <li>Parameters:</li> <li><code>directory</code> (str): The directory path.</li> <li>Returns: None.</li> </ul>"},{"location":"references/compiler/#get_modules","title":"get_modules","text":"<pre><code>def get_modules(self) -&gt; self\n</code></pre> <p>Purpose: Get the list of modules in the specified directory.</p> <ul> <li>Returns: The current instance of Pypox.</li> </ul>"},{"location":"references/compiler/#__create_lifespan","title":"__create_lifespan","text":"<pre><code>def __create_lifespan(modules: List[ModuleType]) -&gt; Callable | None\n</code></pre> <p>Purpose: Creates a lifespan context manager function based on the provided modules.</p> <ul> <li>Parameters:</li> <li><code>modules</code> (List[ModuleType]): The list of modules to check for the presence of \"startup\" and \"shutdown\" functions.</li> <li>Returns: The lifespan context manager function if both \"startup\" and \"shutdown\" functions are present in the modules, otherwise None.</li> </ul>"},{"location":"references/compiler/#__create_config","title":"__create_config","text":"<pre><code>def __create_config(modules: List[ModuleType], type: str) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: Generates a configuration dictionary based on the given modules and type.</p> <ul> <li>Parameters:</li> <li><code>modules</code> (List[Type[ModuleType]]): The list of modules to generate the configuration from.</li> <li><code>type</code> (str): The type of configuration to generate. Valid values are \"FastAPI\" and \"API_ROUTER\".</li> <li>Returns: The generated configuration dictionary.</li> </ul>"},{"location":"references/compiler/#__get_endpoints","title":"__get_endpoints","text":"<pre><code>def __get_endpoints(modules: list[ModuleType]) -&gt; tuple[list[Callable], list[dict[str, Any]]]\n</code></pre> <p>Purpose: Generates a list of endpoints and their corresponding configurations based on a list of modules.</p> <ul> <li>Parameters:</li> <li><code>modules</code> (list[ModuleType]): A list of modules containing endpoint information.</li> <li>Returns: A tuple containing two lists: endpoints (A list of endpoint functions) and configs (A list of endpoint configurations).</li> </ul>"},{"location":"references/compiler/#__call__","title":"__call__","text":"<pre><code>def __call__(*args: Any, **kwds: Any) -&gt; FastAPI\n</code></pre> <p>Purpose: Execute the function when the class instance is called.</p> <ul> <li>Parameters:</li> <li><code>*args</code>: Variable length arguments.</li> <li><code>**kwds</code>: Keyword arguments.</li> <li>Returns: The return value of the function.</li> </ul>"},{"location":"references/database/","title":"Database","text":""},{"location":"references/database/#create_engine_sync","title":"create_engine_sync","text":"<pre><code>async def create_engine_sync(module, username: str = \"\", password: str = \"\", host: str = \"\", port: str = \"\", **kwargs) -&gt; Engine:\n</code></pre> <p>Creates a synchronous SQLAlchemy engine based on the provided module and connection parameters.</p> <ul> <li>Parameters:</li> <li><code>module</code>: The module object representing the database driver.</li> <li><code>username</code> (str): The username for the database connection (default: \"\").</li> <li><code>password</code> (str): The password for the database connection (default: \"\").</li> <li><code>host</code> (str): The host address for the database connection (default: \"\").</li> <li><code>port</code> (str): The port number for the database connection (default: \"\").</li> <li><code>**kwargs</code>: Additional keyword arguments for the SQLAlchemy create_engine function.</li> <li>Returns: An SQLAlchemy engine object.</li> <li>Raises: None.</li> </ul>"},{"location":"references/database/#create_engine_async","title":"create_engine_async","text":"<pre><code>def create_engine_async(module, driver, username: str = \"\", password: str = \"\", host: str = \"\", port: str = \"\", **kwargs) -&gt; AsyncEngine\n</code></pre> <p>Creates an asynchronous SQLAlchemy engine based on the provided module, driver, and connection parameters.</p> <ul> <li>Parameters:</li> <li><code>module</code>: The module object representing the database dialect.</li> <li><code>driver</code>: The database driver to be used.</li> <li><code>username</code> (str): The username for the database connection (optional).</li> <li><code>password</code> (str): The password for the database connection (optional).</li> <li><code>host</code> (str): The host address for the database connection (optional).</li> <li><code>port</code> (str): The port number for the database connection (optional).</li> <li><code>**kwargs</code>: Additional keyword arguments for the SQLAlchemy engine.</li> <li>Returns: An asynchronous SQLAlchemy engine object.</li> <li>Raises: None.</li> </ul>"},{"location":"references/database/#init_database_sync","title":"init_database_sync","text":"<pre><code>async def init_database_sync(engine, module) -&gt; None:\n</code></pre> <p>Initializes the database by creating all tables defined in the SQLModel metadata.</p> <ul> <li>Parameters:</li> <li><code>engine</code> (sqlalchemy.engine.Engine): The SQLAlchemy engine object.</li> <li><code>module</code> (module): The module containing the SQLModel metadata.</li> <li>Returns: None.</li> </ul>"},{"location":"references/database/#init_database_async","title":"init_database_async","text":"<pre><code>async def init_database_async(engine: AsyncEngine, module: Any) -&gt; None:\n</code></pre> <p>Initialize the database asynchronously.</p> <ul> <li>Parameters:</li> <li><code>engine</code> (AsyncEngine): The SQLAlchemy async engine instance.</li> <li><code>module</code> (Any): The module containing the SQLModel metadata.</li> <li>Returns: None.</li> </ul>"},{"location":"references/database/#createsyncengine","title":"createSyncEngine","text":"<pre><code>def createSyncEngine(module: ModuleType, **kwargs) -&gt; None:\n</code></pre> <p>Create a new engine and add it to the context variable.</p> <ul> <li>Parameters:</li> <li><code>module</code> (ModuleType): The module to create the engine for.</li> <li><code>**kwargs</code>: Additional keyword arguments for the create_engine_sync function.</li> <li>Returns: None.</li> </ul>"},{"location":"references/database/#createasyncengine","title":"createAsyncEngine","text":"<pre><code>def createAsyncEngine(module: ModuleType, driver: str, **kwargs) -&gt; None:\n</code></pre> <p>Create a new engine and add it to the context variable.</p> <ul> <li>Parameters:</li> <li><code>module</code> (ModuleType): The module containing the database driver.</li> <li><code>driver</code> (str): The name of the database driver.</li> <li><code>**kwargs</code>: Additional keyword arguments for the create_engine_async function.</li> <li>Returns: None.</li> </ul>"},{"location":"references/database/#getsyncengine","title":"getSyncEngine","text":"<pre><code>def getSyncEngine(database: ModuleType | str) -&gt; Engine\n</code></pre> <p>Retrieves the sync engine for the specified database.</p> <ul> <li>Parameters:</li> <li><code>database</code> (ModuleType | str): The database module or name.</li> <li>Returns: The sync engine for the specified database.</li> </ul>"},{"location":"references/database/#getasyncengine","title":"getAsyncEngine","text":"<pre><code>def getAsyncEngine(database: ModuleType | str) -&gt; AsyncEngine\n</code></pre> <p>Retrieves the asynchronous engine for the specified database.</p> <ul> <li>Parameters:</li> <li><code>database</code> (ModuleType | str): The database module or name.</li> <li>Returns: The asynchronous engine for the specified database.</li> </ul>"},{"location":"references/database/#asyncdbsession","title":"asyncDbSession","text":"<pre><code>def asyncDbSession(database: ModuleType | str) -&gt; AsyncSession:\n</code></pre> <p>Create an asynchronous database session.</p> <ul> <li>Parameters:</li> <li><code>database</code> (ModuleType | str): The database module or the name of the database.</li> <li>Returns: The asynchronous database session.</li> </ul>"},{"location":"references/database/#syncdbsession","title":"syncDbSession","text":"<pre><code>def syncDbSession(database: ModuleType | str) -&gt; Session:\n</code></pre> <p>Create and return a synchronized database session.</p> <ul> <li>Parameters:</li> <li><code>database</code> (ModuleType | str): The database module or the name of the database.</li> <li>Returns: A synchronized database session.</li> </ul>"},{"location":"tutorials/configuration/","title":"Configuration","text":"<p>Pypox provides configuration management via <code>config.py</code>, enabling adjustment of OpenAPI Specification (OAS) values. You can employ <code>config.py</code> at different project levels, affecting the main application or specific routes.</p>"},{"location":"tutorials/configuration/#top-level-configuration-mainpy","title":"Top-Level Configuration (main.py)","text":"<ol> <li>Project Structure Example:    Consider the following structure for top-level configuration:</li> </ol> <pre><code>python_project/\n\u2502\n\u251c\u2500\u2500 main.py\n\u2514\u2500\u2500 config.py\n</code></pre> <ol> <li>Utilizing <code>config.py</code>:</li> <li><code>config.py</code> at the Top Level:      Define primary OAS specifications like title, license, contact, etc., within <code>config.py</code> to affect the entire application.</li> </ol>"},{"location":"tutorials/configuration/#route-specific-configuration","title":"Route-Specific Configuration","text":"<ol> <li>Project Structure Example:    For route-specific configurations, organize your project structure as follows:</li> </ol> <pre><code>python_project/\n\u2502\n\u2514\u2500\u2500 routes/\n    \u2514\u2500\u2500 user/\n        \u251c\u2500\u2500 config.py\n        \u251c\u2500\u2500 get.py\n        \u2514\u2500\u2500 post.py\n        \u2514\u2500\u2500 ...\n</code></pre> <p><code>config.py</code></p> <pre><code>title = \"My sample application\"\nsummary = \"very simple application\"\n# rest of the configuration goes here\n...\n</code></pre> <p>Using <code>config.py</code> within a Route:</p> <p><code>config.py</code> Inside the Route Folder: In this scenario, you can adjust route-specific OAS variables like tags, schemas, etc., by placing a <code>config.py</code> file inside the respective route folder. This allows tailored OAS configurations for individual routes.</p> <p><code>routes/user/config.py</code></p> <pre><code>tags = [\"User information route.\"]\n# rest of the configuration goes here\n...\n</code></pre>"},{"location":"tutorials/configuration/#implementation-guidelines","title":"Implementation Guidelines","text":"<ul> <li>Main Application Configuration:</li> <li>Use top-level <code>config.py</code> to define global OAS settings for the entire application.</li> <li>Route-Specific Configuration:</li> <li>Leverage route-specific <code>config.py</code> files within route folders to customize OAS parameters exclusively for those routes.</li> </ul> <p>Utilize these configuration options to fine-tune your OAS specifications based on the scope of your Pypox application.</p>"},{"location":"tutorials/database/","title":"Database","text":"<p>Pypox simplifies database management using <code>sqlmodel</code> and <code>sqlalchemy</code>, adhering to the DBAPI 2.0 specification common in the Python ecosystem. This tutorial will guide you through setting up and using a database in Pypox.</p>"},{"location":"tutorials/database/#setting-up-the-database","title":"Setting Up the Database","text":"<ul> <li>Creating the Database Structure:   Start by creating a folder named <code>database</code> within your Pypox project directory. Inside this folder, create another folder named <code>SQLITE</code> (representing the database system to use).</li> </ul> <p>Info</p> <p>The folder name convention helps Pypox identify the type of database you intend to connect to. you can use other database such as <code>POSTGRESQL</code>, <code>ORACLE</code>, <code>MYSQL</code> etc.</p> <ul> <li>Generating Database Files:   Inside the <code>SQLITE</code> folder, create a Python file adhering to the naming convention <code>Db.py</code> (or any name you prefer). This Python file will generate the database. For instance, <code>sampleDb.py</code> will result in a database named <code>sampleDb.db</code> as we're using SQLite for this example.</li> </ul> <pre><code>pypox_sample/\n|\n\u2514\u2500\u2500\u2500 database/\n     \u2514\u2500\u2500\u2500SQLITE/\n         \u2514\u2500\u2500\u2500sampleDb.py\n ...\n</code></pre> <ul> <li>Defining Tables:   Within the <code>Db.py</code> file, define a SQLModel table using <code>sqlmodel</code>. Here's an example:</li> </ul> <pre><code>from sqlmodel import SQLModel, Field\n\nclass SampleTable(SQLModel, table=True):\n    id: int = Field(primary_key=True)\n    name: str\n    age: str\n</code></pre>"},{"location":"tutorials/database/#integration-with-pypox","title":"Integration with Pypox","text":"<ol> <li>Initializing the Database Engine:    Navigate to the <code>startup.py</code> file in your project folder. This file manages the startup and shutdown events for the application.    Inside the <code>__call__</code> function in <code>startup.py</code>, import the database you created (<code>sampleDb</code>) and use <code>createAsyncEngine()</code> to initialize the database engine.</li> </ol> <pre><code>from pypox import createAsyncEngine,getAsyncEngine\nfrom pypox.database import init_database_async\nfrom pypox_sample.database.SQLITE import sampleDb\n\n# Create an engine and store it in a context var\ncreateAsyncEngine(sampleDb)\nasync def __call__(app: FastAPI):\n    #initialize database table if doesnt exist\n    init_database_async(getAsyncEngine(sampleDb),sampleDb)\n</code></pre> <ol> <li>Database Usage in Endpoints:    Let's use the database in an endpoint (e.g., <code>routes/user/get.py</code>). Import the necessary function <code>asyncDbSession</code> and the database (<code>sampleDb</code>) and leverage it within an endpoint function.</li> </ol> <pre><code>from pypox import asyncDbSession\nfrom pypox_sample.database.SQLITE import sampleDb\n\nasync def endpoint():\n    # this will get the engine that we created earlier from the startup.py and use it as a session\n    async with await asyncDbSession(sampleDb) as session:\n        # Perform database operations (e.g., query data)\n        return {\"message\": \"Database is now operational!\"}\n</code></pre> <p>By following these steps, you can seamlessly integrate and leverage databases within your Pypox project. Pypox simplifies database initialization, connection management, and CRUD operations, enabling efficient database interactions within your application.</p>"},{"location":"tutorials/lifespan/","title":"Lifespan","text":"<p>Pypox utilizes its own convention for handling application startup and shutdown events, managed by <code>startup.py</code> and <code>shutdown.py</code>. These files contain an <code>async __call__</code> function, which Pypox recognizes as valid lifespans.</p>"},{"location":"tutorials/lifespan/#setting-up-startup-and-shutdown-events","title":"Setting Up Startup and Shutdown Events","text":"<ol> <li>Startup Events (startup.py):    In the <code>startup.py</code> file, define the <code>async __call__</code> function to manage startup events. For instance:</li> </ol> <pre><code>async def __call__(app: FastAPI):\n    print(\"System starting up\")\n</code></pre> <ol> <li>Shutdown Events (shutdown.py):    Similarly, within the <code>shutdown.py</code> file, create the <code>async __call__</code> function to handle shutdown events. For example:</li> </ol> <pre><code>async def __call__(app: FastAPI):\n    print(\"Shutting down the system.\")\n</code></pre>"},{"location":"tutorials/lifespan/#integrating-lifespan-events","title":"Integrating Lifespan Events","text":"<p>These lifespan events can perform various tasks such as initializing connections, cleaning up resources, or performing setup/teardown operations. In your Pypox application, these files can be used for tasks like database initialization or cleanup.</p> <p>Additionally, these lifespan events can be linked to other functionalities within your Pypox application for a seamless integration experience. If you're interested in integrating databases, check out the Database Integration Tutorial for a comprehensive guide on leveraging databases within your Pypox application.</p>"},{"location":"tutorials/websocket/","title":"Websocket","text":"<p>In the previous tutorial, we explored how Pypox leverages its convention-based routing system to recognize valid HTTP endpoints. Now, let's dive into WebSocket endpoint creation with Pypox.</p>"},{"location":"tutorials/websocket/#websocket-endpoint-basics","title":"WebSocket Endpoint Basics","text":"<p>Similar to HTTP methods, Pypox uses its file-based convention to identify WebSocket routes. To create a WebSocket endpoint, utilize a file named <code>socket.py</code>.</p> <p>lets use this file structure as an example.</p> <pre><code>project_root/\n\u2502\n\u251c\u2500\u2500\u2500 get.py\n\u251c\u2500\u2500\u2500 post.py\n\u251c\u2500\u2500\u2500 put.py\n\u251c\u2500\u2500\u2500 delete.py\n\u251c\u2500\u2500\u2500 socket.py\n</code></pre>"},{"location":"tutorials/websocket/#defining-a-websocket-endpoint","title":"Defining a WebSocket Endpoint","text":"<p>An essential aspect of WebSocket endpoints in Pypox is the requirement for an asynchronous function that supports the WebSocket connection. Here's an example of how you can define a WebSocket endpoint within a <code>socket.py</code> file:</p> <pre><code># Example socket.py file\nfrom fastapi import WebSocket\n\nasync def endpoint(websocket: WebSocket):\n    # Logic for handling WebSocket connection\n    await websocket.accept()\n    while True:\n        data = await websocket.receive_text()\n        await websocket.send_text(f\"Message text was: {data}\")\n</code></pre>"},{"location":"tutorials/websocket/#using-the-websocket-parameter","title":"Using the WebSocket Parameter","text":"<p>Note</p> <p>Note that in the <code>endpoint</code> function, the <code>websocket</code> parameter of type <code>WebSocket</code> is essential for handling WebSocket operations. By including <code>WebSocket</code> as a parameter type, both IntelliSense ( or your IDE ) and FastAPI can detect and validate the function as a valid WebSocket endpoint.</p>"},{"location":"tutorials/websocket/#websocket-functionality","title":"WebSocket Functionality","text":"<p>Inside the <code>endpoint</code> function, you can define the logic required to manage WebSocket connections. In this example, the function awaits incoming text messages from the client and sends a modified response back to the client.</p>"},{"location":"tutorials/websocket/#integration-with-pypox","title":"Integration with Pypox","text":"<p>Once you've defined the <code>socket.py</code> file with the <code>endpoint</code> function utilizing the <code>WebSocket</code> parameter, Pypox will automatically recognize it as a valid WebSocket endpoint during initialization. Pypox dynamically sets up WebSocket routes, allowing seamless integration and management of WebSocket connections.</p> <p>By following this convention for WebSocket endpoint creation, Pypox ensures straightforward handling of WebSocket connections, enabling real-time bidirectional communication between clients and the server.</p>"},{"location":"tutorials/routing/cookies/","title":"Cookie Parameters","text":"<p>Pypox leverages FastAPI's capabilities to handle cookies effectively within your API endpoints. Using Pypox conventions and FastAPI features, you can seamlessly manage cookies in your applications.</p>"},{"location":"tutorials/routing/cookies/#setting-up-cookie-handling","title":"Setting up Cookie Handling","text":"<p>To handle cookies, create a folder named <code>api</code> within your project. Inside this folder, set up a file named <code>get.py</code> to create a simple endpoint that interacts with cookies.</p>"},{"location":"tutorials/routing/cookies/#getpy","title":"<code>get.py</code>","text":"<p>Within <code>get.py</code>, define an endpoint function that demonstrates cookie handling:</p> <pre><code>from fastapi import Cookie\n\nasync def endpoint(cookie_id: str = Cookie(None)) -&gt; dict:\n    return {\"Received Cookie ID\": cookie_id}\n</code></pre>"},{"location":"tutorials/routing/cookies/#utilizing-cookies-in-endpoints","title":"Utilizing Cookies in Endpoints","text":"<p>In the <code>get.py</code> file, the <code>endpoint</code> function receives the <code>cookie_id</code> parameter with the <code>Cookie</code> dependency from FastAPI. This parameter allows you to access the value of the incoming cookie, providing functionality to read and process cookies within your endpoint logic.</p> <p>By following this convention, Pypox enables you to work with cookies effortlessly in your FastAPI-based application. The <code>Cookie</code> dependency from FastAPI simplifies the retrieval and handling of cookies within your API endpoints, allowing you to incorporate cookie-related functionality seamlessly.</p> <p>learn more about how FastAPI handles Cookies Here.</p>"},{"location":"tutorials/routing/form_data/","title":"Form Data","text":"<p>Pypox, leveraging FastAPI's capabilities, allows you to handle forms within your API endpoints. By following FastAPI conventions, you can process form data elegantly.</p> <p>Info</p> <p>To use forms, first install <code>python-multipart</code>.</p> <p>E.g. <code>pip install python-multipart.</code></p>"},{"location":"tutorials/routing/form_data/#setting-up-form-handling","title":"Setting up Form Handling","text":"<p>Create a new folder named <code>api</code> within your project structure. Inside this folder, set up a new file named <code>post.py</code> to demonstrate handling form data in an endpoint.</p>"},{"location":"tutorials/routing/form_data/#postpy","title":"<code>post.py</code>","text":"<p>Within the <code>post.py</code> file, define an endpoint function that handles form submissions:</p> <pre><code>from fastapi import Form\n\nasync def endpoint(name: str = Form(), email: str = Form()) -&gt; dict:\n    return {\"Name\": name, \"Email\": email}\n</code></pre>"},{"location":"tutorials/routing/form_data/#utilizing-forms-in-endpoints","title":"Utilizing Forms in Endpoints","text":"<p>In the <code>post.py</code> file, the <code>endpoint</code> function utilizes the <code>Form</code> dependency from FastAPI to receive form data. The <code>name</code> and <code>email</code> parameters represent form fields, where <code>Form(...)</code> denotes required fields.</p> <p>Following this convention in Pypox enables seamless handling of form data within your FastAPI-based application. By utilizing FastAPI's <code>Form</code> dependency, you can easily access and process form submissions within your API endpoints, facilitating efficient form handling operations.</p> <p>learn more about how FastAPI handles Form Data Here.</p>"},{"location":"tutorials/routing/header/","title":"Header Parameters","text":"<p>Pypox, built on FastAPI, allows you to handle HTTP headers conveniently within your API endpoints. Using Pypox conventions and FastAPI features, you can easily access and process headers in your application.</p>"},{"location":"tutorials/routing/header/#setting-up-header-handling","title":"Setting up Header Handling","text":"<p>To work with headers, create a folder named <code>api</code> within your project. Inside this folder, create a file named <code>get.py</code> to set up an endpoint that interacts with headers.</p>"},{"location":"tutorials/routing/header/#getpy","title":"<code>get.py</code>","text":"<p>Within <code>get.py</code>, define an endpoint function that demonstrates header handling:</p> <pre><code>from fastapi import Header\n\nasync def endpoint(user_agent: str = Header(None)) -&gt; dict:\n    return {\"User Agent\": user_agent}\n</code></pre>"},{"location":"tutorials/routing/header/#using-headers-in-endpoints","title":"Using Headers in Endpoints","text":"<p>In the <code>get.py</code> file, the <code>endpoint</code> function receives the <code>user_agent</code> parameter with the <code>Header</code> dependency from FastAPI. This parameter enables you to access the value of the incoming header, providing functionality to read and utilize headers within your endpoint logic.</p> <p>By adhering to this convention, Pypox streamlines the process of working with headers in your FastAPI-based application. Utilizing the <code>Header</code> dependency from FastAPI simplifies the retrieval and utilization of headers within your API endpoints, allowing you to handle header-related operations seamlessly.</p> <p>learn more about how FastAPI handles Headers Here.</p>"},{"location":"tutorials/routing/http/","title":"HTTP Routing","text":"<p>Pypox introduces a distinctive convention-based approach for routing, setting it apart from conventional decorator-based routing systems found in frameworks like Flask and FastAPI. With Pypox, routing is facilitated through a file-based system, simplifying the process and enhancing organization.</p>"},{"location":"tutorials/routing/http/#file-system-conventions","title":"File System Conventions","text":"<p>Pypox utilizes a file-based routing system starting from the <code>routes</code> folder. The base route corresponds to the <code>/</code> endpoint. Additionally, creating an <code>api</code> folder will generate an <code>/api</code> route.</p> <p>Within these folders, you can organize your routes based on HTTP verbs or specific WebSocket routes:</p> <ul> <li>HTTP Verbs: Files named after HTTP verbs (e.g., <code>get.py</code>, <code>post.py</code>, <code>put.py</code>, <code>delete.py</code>, etc.) represent corresponding HTTP methods.</li> <li>WebSocket Route: To create a WebSocket route, utilize the file named <code>socket.py</code>.</li> </ul>"},{"location":"tutorials/routing/http/#creating-routes","title":"Creating Routes","text":"<p>Each file representing an HTTP method or WebSocket route should contain an <code>endpoint</code> method. This method can be asynchronous (async) or a regular function, defining the functionality of the route.</p>"},{"location":"tutorials/routing/http/#example-structure","title":"Example Structure","text":"<p>For instance, consider the following folder structure:</p> <pre><code>project_root/\n\u2502\n\u2514\u2500\u2500\u2500 routes/\n    \u2502\n    \u251c\u2500\u2500\u2500 get.py\n    \u251c\u2500\u2500\u2500 post.py\n    \u251c\u2500\u2500\u2500 put.py\n    \u251c\u2500\u2500\u2500 delete.py\n    \u251c\u2500\u2500\u2500 socket.py\n</code></pre> <p>In this structure:</p> <ul> <li><code>get.py</code>, <code>post.py</code>, <code>put.py</code>, and <code>delete.py</code> represent HTTP methods.</li> <li><code>socket.py</code> corresponds to a WebSocket route.</li> </ul> <p>Note</p> <p>you can also not use <code>routes</code> as main route because <code>routes</code> is just a pypox convention.</p> <pre><code>project_root/\n\u2502\n\u251c\u2500\u2500\u2500 get.py\n\u251c\u2500\u2500\u2500 post.py\n\u251c\u2500\u2500\u2500 put.py\n\u251c\u2500\u2500\u2500 delete.py\n\u251c\u2500\u2500\u2500 socket.py\n</code></pre> <p>this is also a valid starting point when creating pypox application.</p> <p>you can also use <code>/api</code> as a starting point</p> <pre><code>project_root/\n\u2502\n\u2514\u2500\u2500\u2500 api/\n    \u2502\n    \u251c\u2500\u2500\u2500 get.py\n    \u251c\u2500\u2500\u2500 post.py\n    \u251c\u2500\u2500\u2500 put.py\n    \u251c\u2500\u2500\u2500 delete.py\n    \u251c\u2500\u2500\u2500 socket.py\n</code></pre> <p>it's the same as the previous example but we change the base folder to <code>api</code> giving us the endpoint <code>/api</code></p>"},{"location":"tutorials/routing/http/#defining-endpoints","title":"Defining Endpoints","text":"<p>Each of these files (<code>get.py</code>, <code>post.py</code>, etc.) would contain an <code>endpoint</code> method:</p> <pre><code># Example get.py file\nasync def endpoint():\n    # Logic for handling GET requests\n    return {\"message\": \"This is a GET endpoint\"}\n</code></pre> <p>This method defines the functionality associated with the respective HTTP method or WebSocket route.</p>"},{"location":"tutorials/routing/http/#dynamic-route-creation","title":"Dynamic Route Creation","text":"<p>Pypox dynamically recognizes these files as valid HTTP or WebSocket routes based on their names and content. Upon initialization, Pypox automatically sets up these routes, allowing for seamless integration and efficient management of endpoints.</p> <p>By leveraging this convention-based file system for routing, Pypox streamlines the process of organizing and defining routes, contributing to a cleaner, more structured approach to API development.</p>"},{"location":"tutorials/routing/path_params/","title":"Path Parameters","text":"<p>In Pypox, you can create dynamic path parameters similar to FastAPI by utilizing folder naming conventions. Renaming a folder with brackets <code>[name]</code> indicates that it's a dynamic route. This dynamic route name can be directly used as a parameter within an endpoint function.</p>"},{"location":"tutorials/routing/path_params/#defining-dynamic-paths","title":"Defining Dynamic Paths","text":"<ol> <li> <p>Dynamic Route Structure:</p> </li> <li> <p>Rename a folder using brackets to signify it's a dynamic route.      <pre><code>python_project/\n\u2502\n\u2514\u2500\u2500 routes/\n    \u2514\u2500\u2500 user/\n        \u251c\u2500\u2500 [name]/\n        \u2502   \u2514\u2500\u2500 get.py\n        \u2514\u2500\u2500 ...\n</code></pre></p> </li> <li> <p>Creating Dynamic Endpoints:</p> </li> <li>Utilize the dynamic route name as a parameter within the endpoint function.      <pre><code># Example endpoint in /user/[name]/get.py\nasync def endpoint(name: str):\n    # Use 'name' parameter to access the dynamic path parameter value\n    return {\"message\": f\"Hello, {name}!\"}\n</code></pre></li> </ol> <p>Danger</p> <p>Importing items within a dynamic route folder, such as schemas.py, poses a challenge due to Python's restriction on using brackets within import statements. This limitation only allows HTTP and WebSocket conventions to be utilized within this specific folder structure.</p> <p>to solve this problem. simply import it beside the dynamic route folder.</p> <pre><code>python_project/\n\u2502\n\u2514\u2500\u2500 routes/\n    \u2514\u2500\u2500 user/\n        \u251c\u2500\u2500 [name]/\n        \u2502   \u2514\u2500\u2500 get.py\n        \u2514\u2500\u2500 schemas.py\n</code></pre> <p>this will work because it doesn't have any brackets in it. you can now use it in your module.</p> <pre><code>from python_project.routes.user.schemas import MyPydanticTable\n</code></pre>"},{"location":"tutorials/routing/path_params/#accessing-path-parameters","title":"Accessing Path Parameters","text":"<ul> <li>Endpoint Implementation:</li> <li>Define endpoint functions within the corresponding dynamic path folder.</li> <li>Use the parameter name identical to the dynamic route folder name (<code>[name]</code>) to access path parameter values.</li> </ul> <p>This technique allows you to create flexible and dynamic endpoints in Pypox, enabling the extraction of path parameters directly from folder names within your route structure.</p>"},{"location":"tutorials/routing/query_params/","title":"Query Parameters","text":""},{"location":"tutorials/routing/query_params/#using-query-parameters-with-pypox","title":"Using Query Parameters with Pypox","text":"<p>Pypox utilizes FastAPI's capabilities, enabling the seamless integration of query parameters into your API endpoints. By adding parameters to your endpoint function, Pypox and FastAPI will automatically recognize and handle them as query parameters.</p>"},{"location":"tutorials/routing/query_params/#implementing-query-parameters","title":"Implementing Query Parameters","text":"<p>Consider the following example where we define an endpoint in <code>/user/info</code> and expect a query parameter named <code>id</code>.</p> <pre><code># Example: Accessing /user/info?id=123\nasync def endpoint(id: int):\n    return {\"User Info\": {\"ID\": id}}\n</code></pre> <p>In this case, if a request is made to <code>/user/info</code> with a query parameter <code>id</code> containing an integer value (e.g., <code>/user/info?id=123</code>), Pypox will automatically interpret and extract the <code>id</code> value from the query parameters. The endpoint function will then process this parameter and respond accordingly.</p>"},{"location":"tutorials/routing/query_params/#working-with-query-parameters","title":"Working with Query Parameters","text":"<p>Pypox simplifies handling query parameters by allowing you to directly include parameters in your endpoint function. FastAPI's underlying functionality handles the routing and parsing of these parameters seamlessly.</p> <p>By defining parameters within your endpoint function's arguments, such as <code>id</code> in the above example, you can access these query parameters within your endpoint's logic.</p> <p>By following this convention, you can effortlessly work with query parameters in your API endpoints, allowing for dynamic and flexible interaction with your API.</p> <p>This feature adds versatility to your endpoints, enabling users to provide input or retrieve specific data by passing query parameters through the API's URLs.</p>"},{"location":"tutorials/routing/request_body/","title":"Request Body","text":"<p>Pypox leverages FastAPI's capabilities to effortlessly convert JSON request bodies into Pydantic models. By setting up a directory structure and creating necessary files following Pypox conventions, you can seamlessly handle request payloads and convert them into Pydantic models.</p>"},{"location":"tutorials/routing/request_body/#setting-up-the-folder-structure","title":"Setting up the Folder Structure","text":"<p>Start by creating a folder named <code>api</code> within your project. Inside this folder, create two files: <code>post.py</code> and <code>schemas.py</code>. The <code>schemas.py</code> file will contain shared schemas across different route files.</p>"},{"location":"tutorials/routing/request_body/#schemaspy","title":"<code>schemas.py</code>","text":"<p>In <code>schemas.py</code>, define a Pydantic model that represents the structure of the incoming JSON request body:</p> <pre><code>from pydantic import BaseModel\n\nclass MyTable(BaseModel):\n    name: str\n    age: int\n</code></pre>"},{"location":"tutorials/routing/request_body/#postpy","title":"<code>post.py</code>","text":"<p>Within <code>post.py</code>, import the Pydantic model and set up your endpoint function:</p> <pre><code>from python_project.api.schemas import MyTable\n\nasync def endpoint(body: MyTable) -&gt; dict:\n    return {\"user data\": {\"name\": body.name, \"age\": body.age}}\n</code></pre>"},{"location":"tutorials/routing/request_body/#using-pydantic-models-in-endpoints","title":"Using Pydantic Models in Endpoints","text":"<p>By defining a Pydantic model (<code>MyTable</code>) to represent the expected structure of the JSON request body and using it as an argument in your endpoint function (<code>endpoint</code>), Pypox and FastAPI seamlessly handle the JSON payload.</p> <p>By following this convention, Pypox simplifies the handling of request bodies, allowing you to easily define Pydantic models that represent the expected structure of the JSON data. This enables efficient validation and processing of incoming JSON payloads within your API endpoints.</p> <p>learn more about how FastAPI handles request body Here.</p>"},{"location":"tutorials/setup/starter/","title":"Basic Setup","text":"<p>Pypox is a powerful convention-based API framework that simplifies API development on FastAPI. It can be easily installed using Poetry, a Python dependency management and packaging tool.</p>"},{"location":"tutorials/setup/starter/#installing-poetry","title":"Installing Poetry","text":"<p>Firstly, ensure Poetry is installed on your local machine. You can install Poetry by following the official instructions here.</p>"},{"location":"tutorials/setup/starter/#adding-pypox-as-a-dependency","title":"Adding Pypox as a Dependency","text":"<p>Once Poetry is set up, you can add Pypox to your project's dependencies. Run the following command in your terminal:</p> <pre><code>poetry add pypox\n</code></pre> <p>This command will not only add Pypox but also install all necessary dependencies such as <code>FastAPI</code>, <code>SQLModel</code>, <code>SQLAlchemy</code>, and <code>Uvicorn (standard version)</code>. If you prefer using a different ASGI web server, you're free to install and use it instead.</p> <p>Note</p> <p>you can also use other virtual environment or use <code>pip install pypox</code> to install it directly to your current python environment. we recommend using <code>Python 3.11</code> and up for this system to work smoothly.</p>"},{"location":"tutorials/setup/starter/#setting-up-your-project-structure","title":"Setting Up Your Project Structure","text":"<p>To begin using Pypox, create a folder named <code>src</code> where your project files will reside. Inside this folder, include the following files:</p> <ul> <li><code>startup.py</code></li> <li><code>shutdown.py</code></li> <li><code>main.py</code></li> <li><code>config.py</code> (optional)</li> </ul>"},{"location":"tutorials/setup/starter/#file-purposes","title":"File Purposes:","text":"<ul> <li><code>startup.py</code> and <code>shutdown.py</code>: Handle the API's lifespan events.</li> <li><code>main.py</code>: Acts as the entry point of your application when running with Uvicorn (<code>uvicorn src.main:app --reload</code> is an example command).</li> <li><code>config.py</code> (optional): Used for configuring specific settings of your API.</li> </ul>"},{"location":"tutorials/setup/starter/#initializing-pypox","title":"Initializing Pypox","text":"<p>Next, import Pypox in your <code>main.py</code> file and initialize it:</p> <pre><code>from fastapi import FastAPI\nfrom pypox import Pypox\nimport os\n\napp: FastAPI = Pypox(os.path.dirname(__file__))()\n</code></pre> <p>This code automatically traverses your project directory, detecting the predefined conventions set by Pypox. It seamlessly includes them in the server, simplifying the process of serving your API.</p>"},{"location":"tutorials/setup/starter/#serving-it-over-asgi-server","title":"Serving it over ASGI Server","text":"<p>you can now use the command to serve it to http. for this example, we will use uvicorn</p> <pre><code>uvicorn src.main:app --reload\n</code></pre> <p>Note</p> <p>you can also use other ASGI server since Pypox is based on FastAPI. you can use other servers like. <code>Gunicorn</code>, <code>Hypercorn</code>, <code>Daphne</code>, etc. as long as the server complies to ASGI Specification.</p>"},{"location":"tutorials/setup/starter/#tutorials","title":"Tutorials","text":"<ul> <li>Routing Tutorial</li> </ul>"},{"location":"tutorials/setup/starter/#future-tutorials","title":"Future Tutorials","text":"<p>Stay tuned for upcoming tutorials where you'll learn more about utilizing Pypox's conventions effectively. Please note that the documentation is a work in progress, and additional information will be added to help prepare your application for production.</p>"}]}